package main

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"strings"

	"github.com/spf13/cobra"
)

type config struct {
	projectID             string
	githubRepositoryOwner string
	githubRepository      string
	poolName              string
	providerName          string
	unsafe                bool
	serviceAccount        string
}

func main() {
	cobra.EnableCommandSorting = false
	cfg := &config{
		poolName:     "github-actions-pool",
		providerName: "github-provider",
	}

	rootCmd := &cobra.Command{
		CompletionOptions: cobra.CompletionOptions{
			DisableDefaultCmd: true,
		},

		Use:   "gwif",
		Short: "Configure GitHub Actions OIDC Workload Identity Federation",
		Long: `This tool configures GitHub Actions to work without service account keys.
Workload Identity Federation generates temporary credentials for jobs by exchanging
OIDC tokens generated by GitHub, and associating them with service accounts permissions.
Requires elevated permissions in the target Google Cloud Project.
Required Roles: IAM Admin, Workload Identity Federation Admin.

Suggested Usage:
1. Create a pool  			          								|     gwif create pool
2. Create a provider			          							|     gwif create provider
3. Authenticate a service account		  							|     gwif auth
4. Generate a YAML configuration		  							|     gwif yaml
5. Add the YAML configuration in your GitHub Actions workflow
6. Remove any service account keys from GitHub secrets
`,
	}

	// Create the create command
	createCmd := &cobra.Command{
		Use:   "create",
		Short: "Create Workload Identity Federation resources",
	}

	// Create pool subcommand
	poolCmd := &cobra.Command{
		Use:   "pool",
		Short: "Create a Workload Identity pool",
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := AssistConfigForPool(cfg); err != nil {
				return err
			}
			if err := verifyActiveProject(cfg.projectID); err != nil {
				return err
			}
			return CreatePool(cfg)
		},
	}

	// Create provider subcommand
	providerCmd := &cobra.Command{
		Use:   "provider",
		Short: "Create a Workload Identity provider",
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := AssistConfigForProvider(cfg); err != nil {
				return err
			}
			if err := verifyActiveProject(cfg.projectID); err != nil {
				return err
			}

			projectNumber, err := getProjectNumber(cfg.projectID)
			if err != nil {
				return err
			}

			githubRepositoryFullName := fmt.Sprintf("%s/%s", cfg.githubRepositoryOwner, cfg.githubRepository)
			return CreateProvider(cfg, projectNumber, githubRepositoryFullName)
		},
	}

	// Create auth subcommand
	authCmd := &cobra.Command{
		Use:   "auth",
		Short: "Configure service account authentication",
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := AssistConfigForAuth(cfg); err != nil {
				return err
			}
			if err := verifyActiveProject(cfg.projectID); err != nil {
				return err
			}

			projectNumber, err := getProjectNumber(cfg.projectID)
			if err != nil {
				return err
			}

			return AuthServiceAccount(cfg, projectNumber)
		},
	}

	// Create yaml subcommand
	yamlCmd := &cobra.Command{
		Use:   "yaml",
		Short: "Generate GitHub Actions YAML configuration",
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := AssistConfigForAuth(cfg); err != nil {
				return err
			}

			projectNumber, err := getProjectNumber(cfg.projectID)
			if err != nil {
				return err
			}

			DumpYAML(cfg, projectNumber)
			return nil
		},
	}

	// Add flags but make them optional
	rootCmd.PersistentFlags().StringVar(&cfg.projectID, "project", "", "Google Cloud project ID")
	poolCmd.Flags().StringVar(&cfg.poolName, "pool", "", "Workload Identity pool name")

	providerCmd.Flags().BoolVar(&cfg.unsafe, "unsafe", false, "Allow unsafe configurations (allows repository name condition to not be enforced in the provider)")
	providerCmd.Flags().StringVar(&cfg.poolName, "pool", "", "Workload Identity pool name")
	providerCmd.Flags().StringVar(&cfg.providerName, "provider", "", "Workload Identity provider name")
	providerCmd.Flags().StringVar(&cfg.githubRepositoryOwner, "owner", "", "GitHub repository owner (case sensitive)")
	providerCmd.Flags().StringVar(&cfg.githubRepository, "repo", "", "GitHub repository name (case sensitive)")

	authCmd.Flags().StringVar(&cfg.serviceAccount, "service-account", "", "Service account email address")
	authCmd.Flags().StringVar(&cfg.poolName, "pool", "", "Workload Identity pool name")
	authCmd.Flags().StringVar(&cfg.providerName, "provider", "", "Workload Identity provider name")

	yamlCmd.Flags().StringVar(&cfg.poolName, "pool", "", "Workload Identity pool name")
	yamlCmd.Flags().StringVar(&cfg.providerName, "provider", "", "Workload Identity provider name")
	yamlCmd.Flags().StringVar(&cfg.serviceAccount, "service-account", "", "Service account email address")

	// Add create subcommands to create command
	createCmd.AddCommand(poolCmd)
	createCmd.AddCommand(providerCmd)

	// Add commands to root command
	rootCmd.AddCommand(createCmd)
	rootCmd.AddCommand(authCmd)
	rootCmd.AddCommand(yamlCmd)

	if err := rootCmd.Execute(); err != nil {
		log.Println(err)
		os.Exit(1)
	}
}

func verifyActiveProject(projectID string) error {
	cmd := exec.Command("gcloud", "config", "get-value", "project")
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("failed to get current project: %v", err)
	}

	currentProject := strings.TrimSpace(string(output))
	if currentProject != projectID {
		return fmt.Errorf("gcloud is not currently configured to %s", projectID)
	}
	return nil
}

func getProjectNumber(projectID string) (string, error) {
	cmd := exec.Command("gcloud", "projects", "describe", projectID, "--format=value(projectNumber)")
	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to get project number: %v", err)
	}
	return strings.TrimSpace(string(output)), nil
}
